# -*- coding: utf-8 -*-
"""standard task module."""

from __future__ import unicode_literals

import os
import pydoc
from typing import List

from pyloco.grouptask import GroupCmdTask
from pyloco.parse import GroupCmdArgParser
from pyloco.task import Task, load_taskclass
from pyloco.util import (pyloco_print, pyloco_formatter, pyloco_input,
                         StringIO, split_docsection)

_default_title = "{task_name} task"
_default_oneliner = ("{task_name} is a command-line program that runs on "
                     "pyloco framework.")
_default_description = ""
_default_installation = """
Installation
------------

To install {task_name} task, run the following pyloco command. ::

    >>> pyloco install {task_path}
    >>> pyloco {task_path} --version
    {task_name} {task_version}

If pyloco is not available on your computer, please run the following
command to install pyloco, and try again above task installation. ::

    >>> pip install pyloco --user
    >>> pyloco --version
    pyloco {manager_version}

.. note::

    - 'pip' is a Python package manager.
    - Remove '--user' option to run pyloco on a virtual environment.
    - Add '-U' option to 'pip' command to upgrade pyloco.
    - We recommend to use pyloco version {manager_version} or higher.
"""

class _Pyloco_Helper(pydoc.Helper):

    def pyloco_help(self, task, targs):

        from pyloco.mgmttask import mgmt_tasks
        from pyloco.stdtask import standard_tasks

        task_path = os.path.basename(getattr(task, "_path_", task._name_))

        strmap = {
            "task_name": task._name_,
            "task_path": task_path,
            "task_version": task._version_,
            "manager_version": task.parent.get_managerattr("version"),
        }

        lines = []

        #### head ####
        if targs.headnote:
            lines.append(targs.headnote)

        #### title ####

        if targs.title is None:
            title = _default_title.format(**strmap)
        else:
            title = targs.title.format(**strmap)

        lines.append("=" * len(title))
        lines.append(title)
        lines.append("=" * len(title) + "\n")
        lines.append("version: {task_version}\n".format(**strmap))

        #### one-liner and long description and sections ####

        if task.__doc__:
            oneliner, remained = pydoc.splitdoc(task.__doc__)
            description, sections = split_docsection(remained)

        else:
            oneliner, description, sections = None, "", []

        if targs.oneliner is not None:
            oneliner = targs.oneliner.format(**strmap)

        elif not oneliner:
            oneliner = _default_oneliner.format(**strmap)

        if oneliner:
            lines.append(oneliner +"\n")


        if targs.description is not None:
            description = targs.description.format(**strmap)

        elif not description:
            description = _default_description.format(**strmap)

        if description:
            lines.append(description + "\n")

        if targs.installation is None:
            installation = _default_installation.format(**strmap)

        elif (task.__class__ in mgmt_tasks.values() or
                task.__class__ in standard_tasks.values()):
            installation = None

        else:
            installation = targs.installation.format(**strmap)

        
        if installation and targs.add and "installation" in targs.add:
            lines.append(installation)

        if targs.usage is not None:
            lines.append(targs.usage)

        else:
            cmdline = "Command-line syntax"
            lines.append(cmdline)
            lines.append("-" * len(cmdline) + "\n")

            helplines = task._parser.generate_help("-h")
            lines.append("".join(helplines))
            lines.append("\n")

        if targs.section is not None:
            lines.extend(targs.sections)

        else:
            lines.extend(sections)

        #### footnote ####
        if targs.footnote:
            lines.append(targs.footnote)

        outtext = "\n".join(lines)

        outfile = None

        if targs.output.endswith(".rst"):
            outfile = targs.output
            output = "rst"
        elif targs.output.endswith(".htm") or targs.output.endswith(".html"):
            outfile = targs.output
            output = "html"
        else:
            output = "pydoc"

        if output == "pydoc":
            pydoc.pager(outtext)
            return

        if output == "rst":
            with open(outfile, "w") as f:
                f.write("..  -*- coding: utf-8 -*-\n\n")
                f.write(outtext)
            return

        if output == "html":
            # TODO: load sphinx and generate html
            raise NotImplementedError("html support in help task")

        if output == "web":
            # TODO: load sphinx and generate html
            # TODO: connect to helptask webapp
            raise NotImplementedError("web support in help task")


class InputTask(Task):
    """read user input

'input' task takes string input, possibily interactively. Its main usage is
to accept user input and to forward it to other tasks. Using '--calc'
option, user can generate a new variable from Python expression.
"""

    _version_ = "0.1.0"
    _name_ = "input"

    def __init__(self, parent):

        self.add_data_argument("data", nargs="*", required=False, type=str,
                               help="input data")

        self.add_option_argument("-i", "--interactive", action="store_true",
                                 help="interactive user input")
        self.add_option_argument("-p", "--prompt", default=">>> ",
                                 help="command prompt")

        #self._input_dargs = [d[0] for d in self._parser.dargs]
        #self._input_oargs = [o[0] for o in self._parser.oargs]

        self.register_forward("data", type=List[str],
                              help="forward input data")

    def _eval(self, opt):

        for expr in opt.vargs:
            eval(expr, self._env)

        for lhs, rhs in opt.kwargs.items():
            self._env[lhs] = eval(rhs, self._env)

    def perform(self, targs):

        data = targs.data

        if targs.interactive:
            data = [pyloco_input(targs.prompt)]

        #if targs.calc:
        #    for calc in targs.calc:
        #        self._eval(calc)

        self.add_forward(data=data)

        return 0


class GroupInputCmdTask(GroupCmdTask, InputTask):

    def __init__(self, parent):

        super(GroupInputCmdTask, self).__init__(parent)
        InputTask.__init__(self, parent)

    def perform(self, targs):

        retval = InputTask.perform(self, targs)

        if retval is None:
            retval = 0

        InputTask.post_perform(self, targs)
        self._data = self._fwds
        self._fwds = {}

        return super(GroupInputCmdTask, self).perform(targs)

#class GroupInputTask(InputTask):
#
#    _version_ = "0.1.0"
#    _name_ = "groupinput"
#
#    def run(self, argv, subargv=None, forward=None):
#
#        # argument parsing
#        self.group_parser = GroupCmdArgParser(self)
#        self.ddests = []
#        for vargs, kwargs in self.group_parser.dargs:
#            self.ddests.append(vargs[-1].replace("-", "_"))
#            if vargs not in self._parser.dargs:
#                self._parser.dargs.append((vargs, kwargs))
#
#        self.odests = []
#        for vargs, kwargs in self.group_parser.oargs:
#            if vargs not in self._parser.oargs:
#                dest = vargs[-1]
#                dest = dest[1:] if dest[0] == "-" else dest
#                dest = dest[1:] if dest[0] == "-" else dest
#                self.odests.append(dest.replace("-", "_"))
#                self._parser.oargs.append((vargs, kwargs))
#
#        return super(GroupInputTask, self).run(argv, subargv, forward)
#
#    def perform(self, targs):
#
#        out = super(GroupInputTask, self).perform(targs)
#
#        for vargs, kwargs in self._parser.dargs:
#            if vargs not in self._input_dargs:
#                dest = vargs[-1].replace("-", "_")
#                if dest not in self.ddests:
#                    self.ddests.append(dest)
#
#        for vargs, kwargs in self._parser.oargs:
#            if vargs not in self._input_oargs:
#                dest = vargs[-1]
#                dest = dest[1:] if dest[0] == "-" else dest
#                dest = dest[1:] if dest[0] == "-" else dest
#                dest = dest.replace("-", "_")
#                if dest not in self.odests:
#                    self.odests.append(dest)
#
#        gargs = []
#
#        for ddest in self.ddests:
#            val = getattr(targs, ddest, None)
#
#            if val:
#                if isinstance(val, list):
#                    gargs.extend([str(v) for v in val])
#                else:
#                    gargs.append(str(val))
#
#            setattr(targs, ddest, None)
#
#        for odest in self.odests:
#            val = getattr(targs, odest, None)
#
#            if val:
#                if isinstance(val, list):
#                    d = "--"+odest.replace("_", "-")
#                    for v in val:
#                        gargs.extend((d, str(v)))
#                else:
#                    gargs.append("--"+odest.replace("_", "-"))
#                    gargs.append(str(val))
#
#            setattr(targs, odest, None)
#
#        from pyloco.task import GroupTask
#
#        group_task = GroupTask(self.parent)
#
#        self._task_table = group_task._task_table
#        group_task._env.update(self._env)
#
#        out, fwd = group_task.run(gargs, self.subargv, self._fwds)
#        self._fwds.update(fwd)
#
#        return out


class HelpTask(Task):
    """display help page

'help' task displays help page of a task on web browser.
"""

    _version_ = "0.1.0"
    _name_ = "help"

    def __init__(self, parent):

        self.add_data_argument("task", required=None, help="a task name")

        self.add_option_argument("-t", "--title", help="custom title")
        self.add_option_argument("-l", "--oneliner", help="custom one-line description")
        self.add_option_argument("-d", "--description", help="custom multi-line description")
        self.add_option_argument("-u", "--usage", action="append", help="custom usage")
        self.add_option_argument("-i", "--installation", help="custom installation direction")
        self.add_option_argument("-s", "--section", action="append", help="custom section")
        self.add_option_argument("-a", "--add", action="append", help="additional section")
        self.add_option_argument("-n", "--headnote", help="headnote section")
        self.add_option_argument("-f", "--footnote", help="footnote section")

        self.add_option_argument(
            "-o", "--output", default="pydoc",
            help=("generate help for pyloco task in a specified format "
                  "and file (valid options: 'pydoc', 'web', '.rst filepath',"
                  " and '.htm[l] filepath'")
        )
        self.add_option_argument("-w", "--web", action="store_true",
                                 help="display on web browser")

    def run(self, argv, subargv=None, forward=None):

        oidx = None

        if "-o" in argv:
            oidx = argv.index("-o")

        if "--output" in argv:
            oidx = argv.index("--output")

        if oidx is not None:
            if argv[oidx+1] == "web":
                here = os.path.dirname(__file__)
                argv.append("--webapp")
                argv.append(os.path.join(here, "helptask"))
                self.taskattr["webapp.wait2close"] = False

        return super(HelpTask, self).run(argv, subargv, forward)

    def perform(self, targs):

        if targs.task:
            task_class, argv, subargv, objs = load_taskclass(targs.task, [], [])

        else:
            from pyloco.task import OptionTask
            task_class = OptionTask

        helper = _Pyloco_Helper()

        if task_class:
            task = task_class(self.get_proxy())
            from pyloco.plxtask import PlXTask

            if task_class is PlXTask:
                task._setup(argv[0])

            helper.pyloco_help(task, targs)

        else:
            helper.help(targs.task)


class PrintTask(Task):
    """display input text

'print' task displays input text on screen. Its main usage is to print
data forwarded from previous task(s).
"""

    _version_ = "0.1.0"
    _name_ = "print"

    def __init__(self, parent):

        self.add_data_argument("data", nargs="*", help="input text to print")

        self.add_option_argument("--evaluate", dest="evaluate", action="store_true", help="evaluate input")
        self.add_option_argument("-n", "--no-newline", action="store_true",
                                 help="remove newline")

        self.register_forward("stdout", type=str, help="standard output")

    def perform(self, targs):

        end = "" if targs.no_newline else "\n"

        if targs.data:
            l = []

            for d in targs.data:
                if isinstance(d, str):
                    fmt = pyloco_formatter.vformat(str(d), [], self._env)
                    if targs.evaluate:
                        l.append(str(eval(fmt)))
                    else:
                        l.append(fmt)
                else:
                    l.append(str(d))

            out = " ".join(l)
            pyloco_print(out, end=end)
            stdout = out + end
        else:
            stdout = "No data to print."
            pyloco_print(stdout)

        self.add_forward(stdout=stdout)


standard_tasks = {
        "help":             HelpTask,
        "input":            InputTask,
        "print":            PrintTask,
    }
